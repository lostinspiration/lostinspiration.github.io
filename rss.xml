<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Lost Inspiration</title><description>A Memoir</description><link>https://www.kichka.dev/</link><language>en</language><item><title>SQL Server Temporal Tables</title><link>https://www.kichka.dev/posts/sql-temporal-tables/</link><guid isPermaLink="true">https://www.kichka.dev/posts/sql-temporal-tables/</guid><description>SQL snips for querying and enabling temporal tables</description><pubDate>Tue, 23 Dec 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;System Version Query â€“ How To&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;SELECT * 
FROM dbo.MyTable

--( at time zone does not work on literals, use var to work around this limitation )--
DECLARE @AsOf DATETIME2 = &apos;4/8/2019 9:43AM&apos;
SELECT @AsOf = @AsOf AT TIME ZONE &apos;Eastern Standard Time&apos; AT TIME ZONE &apos;UTC&apos;

SELECT *
FROM dbo.MyTable
FOR SYSTEM_TIME AS OF @AsOf --( includes changes where the record was valid during the given time )--
--FOR SYSTEM_TIME ALL --( includes all changes )--
--FOR SYSTEM_TIME FROM @StartDate TO @EndDate --( exclusive of start and end dates )--
--FOR SYSTEM_TIME BETWEEN @StartDate AND @EndDate --( inclusive of start and end dates )--

--( query directly from the history table )--
SELECT *
FROM dbo.MyTableHistory
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Enable System Versioning&lt;/h1&gt;
&lt;p&gt;This snippet will add the required columns &lt;code&gt;ValidFrom&lt;/code&gt; and &lt;code&gt;ValidTo&lt;/code&gt; and enable system versioning with a history table of &lt;code&gt;{Schema}.{TableName}History&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DECLARE
	@TableName SYSNAME = &apos;MyTable&apos;,
	@TableSchema SYSNAME = &apos;dbo&apos;,
	@IsDebug BIT = 0

DECLARE @Sql NVARCHAR(MAX) = &apos;&apos;

--( add sys version columns and enable )--
SELECT @Sql = &apos;
ALTER TABLE [{0}].[{1}]
ADD [ValidFrom] DATETIME2 GENERATED ALWAYS AS ROW START HIDDEN NOT NULL CONSTRAINT [DF[{0}]].[{1}]].[ValidFrom]]]  DEFAULT (sysutcdatetime()),
[ValidTo] DATETIME2 GENERATED ALWAYS AS ROW END HIDDEN NOT NULL CONSTRAINT [DF[{0}]].[{1}]].[ValidTo]]] DEFAULT (CONVERT([datetime2](0),&apos;&apos;9999-12-31 23:59:59&apos;&apos;)),
PERIOD FOR SYSTEM_TIME([ValidFrom], [ValidTo])

ALTER TABLE [{0}].[{1}]
SET (SYSTEM_VERSIONING = ON (HISTORY_TABLE = [{0}].[{1}History]));
&apos;
SELECT @Sql = REPLACE(@Sql, &apos;{0}&apos;, @TableSchema)
SELECT @Sql = REPLACE(@Sql, &apos;{1}&apos;, @TableName)

IF @IsDebug = 1
	PRINT (@Sql)
IF @IsDebug = 0
	EXEC (@Sql)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Disable System Versioning&lt;/h1&gt;
&lt;p&gt;This will disable system versioning on the given table.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DECLARE
	@TableName SYSNAME = &apos;MyTable&apos;,
	@TableSchema SYSNAME = &apos;dbo&apos;,
	@IsDebug BIT = 0

DECLARE @Sql NVARCHAR(MAX) = &apos;&apos;

SELECT @Sql = &apos;
ALTER TABLE [{0}].[{1}]
SET (SYSTEM_VERSIONING = OFF)
&apos;
SELECT @Sql = REPLACE(@Sql, &apos;{0}&apos;, @TableSchema)
SELECT @Sql = REPLACE(@Sql, &apos;{1}&apos;, @TableName)

IF @IsDebug = 1
	PRINT (@Sql)
IF @IsDebug = 0
	EXEC (@Sql)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;~ SK&lt;/p&gt;
</content:encoded></item><item><title>SQL Server See What&apos;s Running</title><link>https://www.kichka.dev/posts/sql-see-whats-running/</link><guid isPermaLink="true">https://www.kichka.dev/posts/sql-see-whats-running/</guid><description>This is a collection of SQL snippets for tracking down what is running and what might be misbehaving</description><pubDate>Mon, 22 Dec 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Below are a collection of SQL query that I use to diagnose and trace what is running on the server.&lt;/p&gt;
&lt;p&gt;This is my goto snippet to quickly identify what is running and the current state of the server. It will provide you cpu and disk read time as well as the query plans which can be used to identify problem children.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DROP TABLE #PERFSNAP

SELECT
    r.cpu_time,
    r.logical_reads,
    r.session_id 
INTO #TEMP
FROM sys.dm_exec_sessions s 
JOIN sys.dm_exec_requests r 
ON s.session_id = r.session_id
--AND s.last_request_start_time = r.start_time
WHERE is_user_process = 1 
 
WAITFOR DELAY &apos;00:00:01&apos;

SELECT 
    [text] = SUBSTRING(
        h.text, 
        (r.statement_start_offset / 2) + 1,
        ((  CASE r.statement_end_offset 
            WHEN -1 
            THEN DATALENGTH(h.text)
            ELSE r.statement_end_offset
            END - r.statement_start_offset) / 2) + 1
    ),
    [cpu_diff] = r.cpu_time - t.cpu_time, 
    [read_diff] = r.logical_reads - t.logical_reads,
    p.query_plan,
    r.wait_type,
    r.wait_time,
    r.last_wait_type,
    r.wait_resource,
    r.command,
    [database] = DB_NAME(r.database_id),
    r.blocking_session_id,
    r.granted_query_memory,
    r.session_id,
    r.reads,
    r.writes,
    r.row_count,
    s.[host_name],
    s.program_name,
    s.login_name
INTO #PERFSNAP
FROM sys.dm_exec_sessions s 
JOIN sys.dm_exec_requests r 
ON s.session_id = r.session_id
AND s.last_request_start_time = r.start_time
FULL JOIN #TEMP t 
ON t.session_id = s.session_id
CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) h
CROSS APPLY sys.dm_exec_query_plan(r.plan_handle) p
ORDER BY 3 desc

DROP TABLE #TEMP

SELECT * FROM #PERFSNAP
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is another variation of the above code snippet just without the cpu and read timing, and query plans.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BEGIN
    -- Do not lock anything, and do not get held up by any locks.
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

    -- What SQL Statements Are Currently Running?
    SELECT
        [spid] = session_Id,
        ecid,
        [database] = DB_NAME(sp.dbid),
        [user] = nt_username,
        [status] = er.status,
        [wait] = wait_type,
        [individual_query] = SUBSTRING(
            qt.text, 
            er.statement_start_offset / 2,
            (   CASE 
                WHEN er.statement_end_offset = -1
                THEN LEN(CONVERT(NVARCHAR(MAX), qt.text)) * 2
                ELSE er.statement_end_offset 
                END - er.statement_start_offset
            ) / 2
        ),
        [parent_query] = qt.text,
        program_name,
        hostname,
        nt_domain,
        start_time
    FROM sys.dm_exec_requests er
    JOIN sys.sysprocesses sp
    ON er.session_id = sp.spid
    CROSS APPLY sys.dm_exec_sql_text(er.sql_handle) qt
    WHERE session_Id &amp;gt; 50 -- ignore system spids
    AND session_Id NOT IN (@@SPID) -- ignore this current statement
    --AND session_Id IN ( 126 )
    --AND DB_NAME(sp.dbid) = &apos;&apos;
    ORDER BY 1, 2
END

--EXECUTE sp_who2 85
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These snips will help track down different types of wait resources and their reasons.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--KEY: 8:281474980315136 (4102a73ebc59)
--( Key Wait Resource )--
SELECT 
    [TableName] = o.name, 
    [IndexName] = i.name,
    [SchemaName] = SCHEMA_NAME(o.schema_id)
FROM sys.partitions p 
JOIN sys.objects o 
ON p.OBJECT_ID = o.OBJECT_ID 
JOIN sys.indexes i 
ON p.OBJECT_ID = i.OBJECT_ID
AND p.index_id = i.index_id 
WHERE p.hobt_id = 281474980315136

--( Page Wait Resource )--
SELECT DB_NAME(68)

-- select the database based on the output above statement then execute the below statement
DBCC traceon (3604)
GO
-- Database_id, file_id, page_id 
DBCC page (68, 1, 492478) 

--( Object Wait Resource )--
--OBJECT: 8:1954106002:0 
SELECT OBJECT_NAME(1954106002)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;~ SK&lt;/p&gt;
</content:encoded></item><item><title>SQL Server Shell Games</title><link>https://www.kichka.dev/posts/sql-shell-games/</link><guid isPermaLink="true">https://www.kichka.dev/posts/sql-shell-games/</guid><description>DELETE large amounts of data from a huge database table with this one simple trick</description><pubDate>Sat, 20 Dec 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;SQL Partition SWITCH Operation&lt;/h1&gt;
&lt;p&gt;With the power of the table partitioning &lt;code&gt;SWITCH&lt;/code&gt; operation you can swap table metadata pointers instantly.&lt;/p&gt;
&lt;p&gt;This can be used on any modern edition of sql server, even if table partioning is not supported. This is because under the hood every table is a single partition. With this you can quickly move data to an empty table and with some &quot;shell games&quot; instantly swap back to the old table.&lt;/p&gt;
&lt;p&gt;I have used this many times to remove billions of rows by selecting out only the few hundred thousand that I wanted to keep into a new table and swapping table partition pointers. The swap is instant and there is little to no downtime.&lt;/p&gt;
&lt;p&gt;Let&apos;s walk through an example of the process.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-- create test set of tables
CREATE TABLE dbo.TEST1(id INT)
CREATE TABLE dbo.TEST2(id INT)

-- populate test1 with 10000 rows of data
DECLARE @i INT = 0
WHILE @i &amp;lt; 10000
BEGIN
    INSERT INTO dbo.TEST1(id)
    VALUES(@i)
    SELECT @i += 1
END

-- view current state of things
SELECT * FROM dbo.TEST1
SELECT * FROM dbo.TEST2

-- switch data to second table
ALTER TABLE dbo.TEST1
SWITCH TO dbo.TEST2

-- view current state of things
SELECT * FROM dbo.TEST1
SELECT * FROM dbo.TEST2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have an idea of how this works, you can imagine that you have a table with billions of rows that you want to delete. DELETEs have to acquire a lock on the table at some level potentially preventing others from interacting with it. SELECTs however are much quicker and can be done in parallel without affecting others.&lt;/p&gt;
&lt;p&gt;Below, we select out just the handful of rows that we want, truncate the original table, then swap the table pointers.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-- =========================
-- TRUNCATE TABLE SHELL GAME
-- =========================
-- move out set of data i want to keep
SELECT TOP 1000 * INTO dbo.TEMP_SHELL FROM dbo.TEST2

-- truncate orig table
TRUNCATE TABLE dbo.TEST2

-- move data metadata from shell to orig table
ALTER TABLE dbo.TEMP_SHELL
SWITCH TO dbo.TEST2

-- view current state of things
SELECT * FROM dbo.TEMP_SHELL
SELECT * FROM dbo.TEST2

-- remove shell table
DROP TABLE dbo.TEMP_SHELL

-- view current state of things
SELECT * FROM dbo.TEST1
SELECT * FROM dbo.TEST2

-- cleanup
DROP TABLE dbo.TEST1
DROP TABLE dbo.TEST2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This process has saved me countless hours of data processing and downtime.&lt;/p&gt;
&lt;p&gt;I have used it in ETLs, ad-hoc table cleanups, as well as to create a simple data archiving process that moves old data by quarter into another table for historical reporting keeping the primary table lean.&lt;/p&gt;
&lt;p&gt;This may not be such a concern now that Microsoft has opened up the table partitioning feature to all editions of SQL Server, but still useful for situations where the complexity of managing table partitioning outweighs the benifits.&lt;/p&gt;
&lt;p&gt;~ SK&lt;/p&gt;
</content:encoded></item><item><title>Start of a Journey</title><link>https://www.kichka.dev/posts/start-of-a-journey/</link><guid isPermaLink="true">https://www.kichka.dev/posts/start-of-a-journey/</guid><description>Today I embark on a new journey of writing down my thoughts and experiences in software development</description><pubDate>Mon, 15 Dec 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;A new Beginning&lt;/h1&gt;
&lt;p&gt;For a long time now I have been wanting to start writing my thoughts down on paper. I have a physical notebook where my thoughts and notes are haphazardly written which has this big downside of not being very searchable.&lt;/p&gt;
&lt;p&gt;So over the next couple of weeks I will be working on digitizing these notes and thoughts here.&lt;/p&gt;
&lt;p&gt;Come join me on this journey of inspiration lost and found.&lt;/p&gt;
&lt;p&gt;~ SK&lt;/p&gt;
</content:encoded></item></channel></rss>