<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Lost Inspiration</title><description>A Memoir</description><link>https://www.kichka.dev/</link><language>en</language><item><title>SQL Voodoo Black Magic</title><link>https://www.kichka.dev/posts/sql-voodoo-blackmagic/</link><guid isPermaLink="true">https://www.kichka.dev/posts/sql-voodoo-blackmagic/</guid><description>SQL snips for querying sysobjects table and using the results to dynamically generate SQL query</description><pubDate>Sat, 27 Dec 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Sometimes you want to be able to dynamically construct table definitions to perform different actions, such as creating a copy of a table on a different database, compare table schema, sync table data where the tables are not guarenteed to have the same schema, generate update, merge, select and insert statements and not have to keep adjusting the code as the table schema drifts.&lt;/p&gt;
&lt;p&gt;Below we will go through a few of these scenarios, but first lets define the &quot;black magic&quot; that the rest of the examples will build upon.&lt;/p&gt;
&lt;h1&gt;Black Magic&lt;/h1&gt;
&lt;p&gt;These are the exact same query but produce a &lt;code&gt;#Source&lt;/code&gt; and &lt;code&gt;#Destination&lt;/code&gt; temp tables that the examples will use.&lt;/p&gt;
&lt;h2&gt;Select Source Schema&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;DECLARE
	@TableName SYSNAME = &apos;MyTable&apos;,
	@TableSchema SYSNAME = &apos;dbo&apos;

IF OBJECT_ID(&apos;tempdb..#Source&apos;) IS NOT NULL
	DROP TABLE #Source

SELECT
	[ColumnId] = sc.[column_id],
	[ColumnName] = sc.[name] COLLATE DATABASE_DEFAULT,
	-- adjust timestamp type to varbinary
	[Type] = CASE WHEN st.[user_type_id] = 189 THEN &apos;varbinary&apos; ELSE st.[name] END COLLATE DATABASE_DEFAULT,
	-- adjust nvarchar length to half what is reported since it takes 2 bytes to store unicode, and adjust timestamp to the translated varbinary length
	[Length] = CASE WHEN sc.[max_length] = -1 THEN -1 WHEN st.[user_type_id] = 231 THEN sc.[max_length] / 2 WHEN st.[user_type_id] = 189 THEN 85 ELSE sc.[max_length] END,
	[Precision] = sc.[precision], 
	[Scale] = sc.[scale],
	[IsNullable] = sc.[is_nullable]
INTO #Source
FROM [sys].[objects] so
JOIN [sys].[columns] sc
ON so.[object_id] = sc.[object_id]
JOIN [sys].[types] st
ON sc.[user_type_id] = st.[user_type_id]
JOIN [sys].[schemas] ss
ON so.[schema_id] = ss.[schema_id]
WHERE so.[name] = @TableName AND ss.[name] = @TableSchema
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Select Destination Schema&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;DECLARE
	@TableName SYSNAME = &apos;MyTable&apos;,
	@TableSchema SYSNAME = &apos;dbo&apos;

IF OBJECT_ID(&apos;tempdb..#Destination&apos;) IS NOT NULL
	DROP TABLE #Destination

SELECT
	[ColumnId] = sc.[column_id],
	[ColumnName] = sc.[name] COLLATE DATABASE_DEFAULT,
	-- adjust timestamp type to varbinary
	[Type] = CASE WHEN st.[user_type_id] = 189 THEN &apos;varbinary&apos; ELSE st.[name] END COLLATE DATABASE_DEFAULT,
	-- adjust nvarchar length to half what is reported since it takes 2 bytes to store unicode, and adjust timestamp to the translated varbinary length
	[Length] = CASE WHEN sc.[max_length] = -1 THEN -1 WHEN st.[user_type_id] = 231 THEN sc.[max_length] / 2 WHEN st.[user_type_id] = 189 THEN 85 ELSE sc.[max_length] END,
	[Precision] = sc.[precision], 
	[Scale] = sc.[scale],
	[IsNullable] = sc.[is_nullable]
INTO #Destination
FROM [sys].[objects] so
JOIN [sys].[columns] sc
ON so.[object_id] = sc.[object_id]
JOIN [sys].[types] st
ON sc.[user_type_id] = st.[user_type_id]
JOIN [sys].[schemas] ss
ON so.[schema_id] = ss.[schema_id]
WHERE so.[name] = @TableName AND ss.[name] = @TableSchema
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Example – Create Table Copy&lt;/h1&gt;
&lt;p&gt;Create a copy of the table using the source schema information possibly injecting extra columns in the copy.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DECLARE
	@TableName SYSNAME = &apos;MyTable&apos;,
	@TableSchema SYSNAME = &apos;dbo&apos;,
	@IsDebug BIT = 0

DECLARE
	@DataType NVARCHAR(200),
	@Length INT,
	@Precision INT,
	@Scale INT,
	@IsNullable INT,
	@ColumnName NVARCHAR(200),
	@Statement NVARCHAR(MAX) = &apos;&apos;

DECLARE x CURSOR FAST_FORWARD FOR
	SELECT [ColumnName], [Type], [Length], [Precision], [Scale], [IsNullable]
	FROM #Source
	ORDER BY [ColumnId]

OPEN x
FETCH NEXT FROM x INTO @ColumnName, @DataType, @Length, @Precision, @Scale, @IsNullable
WHILE @@FETCH_STATUS = 0
BEGIN
	DECLARE @NullClause NVARCHAR(10) = &apos; NULL&apos;
	IF @IsNullable = 0
	BEGIN
		SELECT @NullClause = &apos; NOT NULL&apos;
	END

	IF @DataType = &apos;timestamp&apos;
	BEGIN
		SELECT @DataType = &apos;varbinary&apos;
		SELECT @Length = 85
	END

	IF @DataType IN(&apos;char&apos;,&apos;varchar&apos;,&apos;binary&apos;,&apos;varbinary&apos;,&apos;nvarchar&apos;,&apos;nchar&apos;)
	BEGIN
		SELECT @Statement = @Statement + &apos;[&apos; + @ColumnName + &apos;] &apos; + @DataType + &apos;(&apos; + ISNULL(NULLIF(CONVERT(NVARCHAR,@Length), &apos;-1&apos;), &apos;MAX&apos;) + &apos;)&apos; + @NullClause + &apos;,&apos;
	END
	ELSE IF @DataType IN(&apos;decimal&apos;,&apos;numeric&apos;)
	BEGIN
		SELECT @Statement = @Statement + &apos;[&apos; + @ColumnName + &apos;] &apos; + @DataType + &apos;(&apos; + CONVERT(NVARCHAR,@Precision) + &apos;,&apos; + CONVERT(NVARCHAR,@Scale) + &apos;)&apos;  + @NullClause + &apos;,&apos;
	END
	ELSE
	BEGIN
		SELECT @Statement = @Statement + &apos;[&apos; + @ColumnName + &apos;] &apos; + @DataType + @NullClause + &apos;,&apos;
	END
FETCH NEXT FROM x INTO @ColumnName, @DataType, @Length, @Precision, @Scale, @IsNullable
END
CLOSE x
DEALLOCATE x

SELECT @Statement = SUBSTRING(@Statement, 1, LEN(@Statement) - 1)

DECLARE @Sql NVARCHAR(MAX) = &apos;&apos;

SELECT @Sql = &apos;
CREATE TABLE [{0}].[{1}](
{2}
)&apos;

SELECT @Sql = REPLACE(@Sql, &apos;{0}&apos;, @TableSchema)
SELECT @Sql = REPLACE(@Sql, &apos;{1}&apos;, @TableName)
SELECT @Sql = REPLACE(@Sql, &apos;{2}&apos;, @Statement)

IF @IsDebug = 1
	PRINT (@Sql)
IF @IsDebug = 0
	EXEC (@Sql)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Example – Schema Diff&lt;/h1&gt;
&lt;p&gt;Below are a few ways you can use this information to find;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;columns that have changed&lt;/li&gt;
&lt;li&gt;columns that are missing from the destination&lt;/li&gt;
&lt;li&gt;columns that have been removed from the source and not the destination&lt;/li&gt;
&lt;li&gt;columns that both tables have in common&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;IF OBJECT_ID(&apos;tempdb..#CHANGED_COLUMNS&apos;) IS NOT NULL
	DROP TABLE #CHANGED_COLUMNS

SELECT
    [ColumnName],
    [Type],
    [Length],
    [Precision], 
    [Scale]
INTO #CHANGED_COLUMNS
FROM #Source
EXCEPT
SELECT
    [ColumnName],
    [Type],
    [Length],
    [Precision], 
    [Scale]
FROM #Destination


IF OBJECT_ID(&apos;tempdb..#MISSING_COLUMNS&apos;) IS NOT NULL
	DROP TABLE #MISSING_COLUMNS

SELECT
    [ColumnName]
INTO #MISSING_COLUMNS
FROM #Source
EXCEPT
SELECT
    [ColumnName]
FROM #Destination

IF OBJECT_ID(&apos;tempdb..#DELETED_COLUMNS&apos;) IS NOT NULL
	DROP TABLE #DELETED_COLUMNS

SELECT
    [ColumnName]
INTO #DELETED_COLUMNS
FROM #Destination
EXCEPT
SELECT
    [ColumnName]
FROM #SOURCE

IF OBJECT_ID(&apos;tempdb..#SHARED_COLUMNS&apos;) IS NOT NULL
	DROP TABLE #SHARED_COLUMNS

SELECT
    [ColumnName]
INTO #SHARED_COLUMNS
FROM #Source
INTERSECT
SELECT
    [ColumnName]
FROM #Destination
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Example – Sync Destination Schema with Source&lt;/h1&gt;
&lt;p&gt;Here we will cursor over the columns that are missing and either create a series of &lt;code&gt;ALTER TABLE&lt;/code&gt; statements to bring the destination table in sync with the source.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DECLARE
	@TableName SYSNAME = &apos;MyTable&apos;,
	@TableSchema SYSNAME = &apos;dbo&apos;,
	@IsDebug BIT = 0

IF OBJECT_ID(&apos;tempdb..#CHANGED_COLUMNS&apos;) IS NOT NULL
	DROP TABLE #CHANGED_COLUMNS

SELECT
    [ColumnName],
    [Type],
    [Length],
    [Precision], 
    [Scale]
INTO #CHANGED_COLUMNS
FROM #Source
EXCEPT
SELECT
    [ColumnName],
    [Type],
    [Length],
    [Precision], 
    [Scale]
FROM #Destination

DECLARE
	@Statement NVARCHAR(MAX) = &apos;&apos;,
	@AlterColumnStatement NVARCHAR(MAX) = &apos;&apos;,
	@ColumnName NVARCHAR(200),
	@Sql NVARCHAR(MAX) = &apos;&apos;

IF EXISTS (SELECT 1 FROM #CHANGED_COLUMNS)
BEGIN
	DECLARE 
		@DataType NVARCHAR(200),
		@Length INT,
		@Precision INT,
		@Scale INT

	DECLARE
		@HasExistingColumns INT = 0,
		@HasNewColumns INT = 0

	DECLARE x CURSOR FOR
		SELECT [ColumnName], [Type], [Length], [Precision], [Scale]
		FROM #COLUMNS
		ORDER BY 1

	OPEN x
	FETCH NEXT FROM x INTO @ColumnName, @DataType, @Length, @Precision, @Scale
	WHILE @@FETCH_STATUS = 0
	BEGIN
		DECLARE @Part NVARCHAR(MAX)
		DECLARE @AlterColumnStub NVARCHAR(MAX) = &apos;
ALTER TABLE [{2}].[{0}]
ALTER COLUMN {1}&apos;

		DECLARE @ColumnExists INT = 0
		IF EXISTS(SELECT 1 FROM #Destination WHERE [ColumnName] = @ColumnName)
		BEGIN
			SELECT @ColumnExists = 1
			SELECT @HasExistingColumns = 1
		END
		ELSE
		BEGIN
			SELECT @HasNewColumns = 1
		END

		IF @DataType = &apos;timestamp&apos;
		BEGIN
			SELECT @DataType = &apos;varbinary&apos;
			SELECT @Length = 85
		END

		IF @DataType IN(&apos;char&apos;,&apos;varchar&apos;,&apos;binary&apos;,&apos;varbinary&apos;,&apos;nvarchar&apos;,&apos;nchar&apos;)
		BEGIN
			SELECT @Part = &apos;[&apos; + @ColumnName + &apos;] &apos; + @DataType + &apos;(&apos; + ISNULL(NULLIF(CONVERT(NVARCHAR,@Length), &apos;-1&apos;), &apos;MAX&apos;) + &apos;)&apos;

			IF(@ColumnExists = 1)
			BEGIN
				SELECT @AlterColumnStatement = @AlterColumnStatement + REPLACE(@AlterColumnStub, &apos;{1}&apos;, @Part)
			END
			ELSE
			BEGIN
				SELECT @Statement = @Statement + @Part + &apos;,&apos;
			END
		END
		ELSE IF @DataType IN(&apos;decimal&apos;,&apos;numeric&apos;)
		BEGIN
			SELECT @Part = &apos;[&apos; + @ColumnName + &apos;] &apos; + @DataType + &apos;(&apos; + CONVERT(NVARCHAR,@Precision) + &apos;,&apos; + CONVERT(NVARCHAR,@Scale) + &apos;)&apos;

			IF(@ColumnExists = 1)
			BEGIN
				SELECT @AlterColumnStatement = @AlterColumnStatement + REPLACE(@AlterColumnStub, &apos;{1}&apos;, @Part)
			END
			ELSE
			BEGIN
				SELECT @Statement = @Statement + @Part + &apos;,&apos;
			END
		END
		ELSE
		BEGIN
			SELECT @Part = &apos;[&apos; + @ColumnName + &apos;] &apos; + @DataType

			IF(@ColumnExists = 1)
			BEGIN
				SELECT @AlterColumnStatement = @AlterColumnStatement + REPLACE(@AlterColumnStub, &apos;{1}&apos;, @Part)
			END
			ELSE
			BEGIN
				SELECT @Statement = @Statement + @Part + &apos;,&apos;
			END
		END
	FETCH NEXT FROM x INTO @ColumnName, @DataType, @Length, @Precision, @Scale
	END
	CLOSE x
	DEALLOCATE x

	IF (LEN(@Statement) &amp;gt; 1)
	BEGIN
		SELECT @Statement = SUBSTRING(@Statement, 1, LEN(@Statement) - 1)
	END

	-- determine if is alter or create statement
	IF OBJECT_ID(@EntityName) IS NOT NULL
	BEGIN
		IF (@HasExistingColumns = 1)
		BEGIN
			SELECT @Sql += @AlterColumnStatement
		END
		
		IF (@HasNewColumns = 1)
		BEGIN
			SELECT @Sql += &apos;
ALTER TABLE [{2}].[{0}]
ADD {1}&apos;
		END
	END

	SELECT @Sql = REPLACE(@Sql, &apos;{0}&apos;, @TableName)
	SELECT @Sql = REPLACE(@Sql, &apos;{1}&apos;, @Statement)
	SELECT @Sql = REPLACE(@Sql, &apos;{2}&apos;, @TableSchema)

    IF @IsDebug = 1
        PRINT (@Sql)
    IF @IsDebug = 0
        EXEC (@Sql)
END
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Example – Generate Statement Layouts&lt;/h1&gt;
&lt;p&gt;Here we generate layouts that can be used in &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; statements assuming the source table is aliased as &lt;code&gt;[source]&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IF OBJECT_ID(&apos;tempdb..#SHARED_COLUMNS&apos;) IS NOT NULL
	DROP TABLE #SHARED_COLUMNS

SELECT
    [ColumnName]
INTO #SHARED_COLUMNS
FROM #Source
INTERSECT
SELECT
    [ColumnName]
FROM #Destination

-- generate layout --
DECLARE
    @ColumnFormat NVARCHAR(MAX) = &apos;&apos;,
    @UpdateFormat NVARCHAR(MAX) = &apos;&apos;,
    @ValuesFormat NVARCHAR(MAX) = &apos;&apos;

SELECT
    @ColumnFormat = STUFF((SELECT &apos;, [&apos; + [ColumnName] + &apos;]&apos; FROM #SHARED_COLUMNS ORDER BY [ColumnName] FOR XML PATH(&apos;&apos;)), 1, 2, &apos;&apos;),
    @UpdateFormat = STUFF((SELECT &apos;, [&apos; + [ColumnName] + &apos;] = [source].[&apos; + [ColumnName] + &apos;]&apos; FROM #SHARED_COLUMNS ORDER BY [ColumnName] FOR XML PATH(&apos;&apos;)), 1, 2, &apos;&apos;),
    @ValuesFormat = STUFF((SELECT &apos;, [source].[&apos; + [ColumnName] + &apos;]&apos; FROM #SHARED_COLUMNS ORDER BY [ColumnName] FOR XML PATH(&apos;&apos;)), 1, 2, &apos;&apos;)

PRINT @ColumnFormat
PRINT @UpdateFormat
PRINT @ValuesFormat
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;~ SK&lt;/p&gt;
</content:encoded></item><item><title>SQL Server Temporal Tables</title><link>https://www.kichka.dev/posts/sql-temporal-tables/</link><guid isPermaLink="true">https://www.kichka.dev/posts/sql-temporal-tables/</guid><description>SQL snips for querying and enabling temporal tables</description><pubDate>Tue, 23 Dec 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;System Version Query – How To&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;SELECT * 
FROM dbo.MyTable

--( at time zone does not work on literals, use var to work around this limitation )--
DECLARE @AsOf DATETIME2 = &apos;4/8/2019 9:43AM&apos;
SELECT @AsOf = @AsOf AT TIME ZONE &apos;Eastern Standard Time&apos; AT TIME ZONE &apos;UTC&apos;

SELECT *
FROM dbo.MyTable
FOR SYSTEM_TIME AS OF @AsOf --( includes changes where the record was valid during the given time )--
--FOR SYSTEM_TIME ALL --( includes all changes )--
--FOR SYSTEM_TIME FROM @StartDate TO @EndDate --( exclusive of start and end dates )--
--FOR SYSTEM_TIME BETWEEN @StartDate AND @EndDate --( inclusive of start and end dates )--

--( query directly from the history table )--
SELECT *
FROM dbo.MyTableHistory
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Enable System Versioning&lt;/h1&gt;
&lt;p&gt;This snippet will add the required columns &lt;code&gt;ValidFrom&lt;/code&gt; and &lt;code&gt;ValidTo&lt;/code&gt; and enable system versioning with a history table of &lt;code&gt;{Schema}.{TableName}History&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DECLARE
	@TableName SYSNAME = &apos;MyTable&apos;,
	@TableSchema SYSNAME = &apos;dbo&apos;,
	@IsDebug BIT = 0

DECLARE @Sql NVARCHAR(MAX) = &apos;&apos;

--( add sys version columns and enable )--
SELECT @Sql = &apos;
ALTER TABLE [{0}].[{1}]
ADD [ValidFrom] DATETIME2 GENERATED ALWAYS AS ROW START HIDDEN NOT NULL CONSTRAINT [DF[{0}]].[{1}]].[ValidFrom]]]  DEFAULT (sysutcdatetime()),
[ValidTo] DATETIME2 GENERATED ALWAYS AS ROW END HIDDEN NOT NULL CONSTRAINT [DF[{0}]].[{1}]].[ValidTo]]] DEFAULT (CONVERT([datetime2](0),&apos;&apos;9999-12-31 23:59:59&apos;&apos;)),
PERIOD FOR SYSTEM_TIME([ValidFrom], [ValidTo])

ALTER TABLE [{0}].[{1}]
SET (SYSTEM_VERSIONING = ON (HISTORY_TABLE = [{0}].[{1}History]));
&apos;
SELECT @Sql = REPLACE(@Sql, &apos;{0}&apos;, @TableSchema)
SELECT @Sql = REPLACE(@Sql, &apos;{1}&apos;, @TableName)

IF @IsDebug = 1
	PRINT (@Sql)
IF @IsDebug = 0
	EXEC (@Sql)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Disable System Versioning&lt;/h1&gt;
&lt;p&gt;This will disable system versioning on the given table.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DECLARE
	@TableName SYSNAME = &apos;MyTable&apos;,
	@TableSchema SYSNAME = &apos;dbo&apos;,
	@IsDebug BIT = 0

DECLARE @Sql NVARCHAR(MAX) = &apos;&apos;

SELECT @Sql = &apos;
ALTER TABLE [{0}].[{1}]
SET (SYSTEM_VERSIONING = OFF)
&apos;
SELECT @Sql = REPLACE(@Sql, &apos;{0}&apos;, @TableSchema)
SELECT @Sql = REPLACE(@Sql, &apos;{1}&apos;, @TableName)

IF @IsDebug = 1
	PRINT (@Sql)
IF @IsDebug = 0
	EXEC (@Sql)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;~ SK&lt;/p&gt;
</content:encoded></item><item><title>SQL Server See What&apos;s Running</title><link>https://www.kichka.dev/posts/sql-see-whats-running/</link><guid isPermaLink="true">https://www.kichka.dev/posts/sql-see-whats-running/</guid><description>This is a collection of SQL snippets for tracking down what is running and what might be misbehaving</description><pubDate>Mon, 22 Dec 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Below are a collection of SQL query that I use to diagnose and trace what is running on the server.&lt;/p&gt;
&lt;p&gt;This is my goto snippet to quickly identify what is running and the current state of the server. It will provide you cpu and disk read time as well as the query plans which can be used to identify problem children.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DROP TABLE #PERFSNAP

SELECT
    r.cpu_time,
    r.logical_reads,
    r.session_id 
INTO #TEMP
FROM sys.dm_exec_sessions s 
JOIN sys.dm_exec_requests r 
ON s.session_id = r.session_id
--AND s.last_request_start_time = r.start_time
WHERE is_user_process = 1 
 
WAITFOR DELAY &apos;00:00:01&apos;

SELECT 
    [text] = SUBSTRING(
        h.text, 
        (r.statement_start_offset / 2) + 1,
        ((  CASE r.statement_end_offset 
            WHEN -1 
            THEN DATALENGTH(h.text)
            ELSE r.statement_end_offset
            END - r.statement_start_offset) / 2) + 1
    ),
    [cpu_diff] = r.cpu_time - t.cpu_time, 
    [read_diff] = r.logical_reads - t.logical_reads,
    p.query_plan,
    r.wait_type,
    r.wait_time,
    r.last_wait_type,
    r.wait_resource,
    r.command,
    [database] = DB_NAME(r.database_id),
    r.blocking_session_id,
    r.granted_query_memory,
    r.session_id,
    r.reads,
    r.writes,
    r.row_count,
    s.[host_name],
    s.program_name,
    s.login_name
INTO #PERFSNAP
FROM sys.dm_exec_sessions s 
JOIN sys.dm_exec_requests r 
ON s.session_id = r.session_id
AND s.last_request_start_time = r.start_time
FULL JOIN #TEMP t 
ON t.session_id = s.session_id
CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) h
CROSS APPLY sys.dm_exec_query_plan(r.plan_handle) p
ORDER BY 3 desc

DROP TABLE #TEMP

SELECT * FROM #PERFSNAP
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is another variation of the above code snippet just without the cpu and read timing, and query plans.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BEGIN
    -- Do not lock anything, and do not get held up by any locks.
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

    -- What SQL Statements Are Currently Running?
    SELECT
        [spid] = session_Id,
        ecid,
        [database] = DB_NAME(sp.dbid),
        [user] = nt_username,
        [status] = er.status,
        [wait] = wait_type,
        [individual_query] = SUBSTRING(
            qt.text, 
            er.statement_start_offset / 2,
            (   CASE 
                WHEN er.statement_end_offset = -1
                THEN LEN(CONVERT(NVARCHAR(MAX), qt.text)) * 2
                ELSE er.statement_end_offset 
                END - er.statement_start_offset
            ) / 2
        ),
        [parent_query] = qt.text,
        program_name,
        hostname,
        nt_domain,
        start_time
    FROM sys.dm_exec_requests er
    JOIN sys.sysprocesses sp
    ON er.session_id = sp.spid
    CROSS APPLY sys.dm_exec_sql_text(er.sql_handle) qt
    WHERE session_Id &amp;gt; 50 -- ignore system spids
    AND session_Id NOT IN (@@SPID) -- ignore this current statement
    --AND session_Id IN ( 126 )
    --AND DB_NAME(sp.dbid) = &apos;&apos;
    ORDER BY 1, 2
END

--EXECUTE sp_who2 85
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These snips will help track down different types of wait resources and their reasons.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--KEY: 8:281474980315136 (4102a73ebc59)
--( Key Wait Resource )--
SELECT 
    [TableName] = o.name, 
    [IndexName] = i.name,
    [SchemaName] = SCHEMA_NAME(o.schema_id)
FROM sys.partitions p 
JOIN sys.objects o 
ON p.OBJECT_ID = o.OBJECT_ID 
JOIN sys.indexes i 
ON p.OBJECT_ID = i.OBJECT_ID
AND p.index_id = i.index_id 
WHERE p.hobt_id = 281474980315136

--( Page Wait Resource )--
SELECT DB_NAME(68)

-- select the database based on the output above statement then execute the below statement
DBCC traceon (3604)
GO
-- Database_id, file_id, page_id 
DBCC page (68, 1, 492478) 

--( Object Wait Resource )--
--OBJECT: 8:1954106002:0 
SELECT OBJECT_NAME(1954106002)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;~ SK&lt;/p&gt;
</content:encoded></item><item><title>SQL Server Shell Games</title><link>https://www.kichka.dev/posts/sql-shell-games/</link><guid isPermaLink="true">https://www.kichka.dev/posts/sql-shell-games/</guid><description>DELETE large amounts of data from a huge database table with this one simple trick</description><pubDate>Sat, 20 Dec 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;SQL Partition SWITCH Operation&lt;/h1&gt;
&lt;p&gt;With the power of the table partitioning &lt;code&gt;SWITCH&lt;/code&gt; operation you can swap table metadata pointers instantly.&lt;/p&gt;
&lt;p&gt;This can be used on any modern edition of sql server, even if table partioning is not supported. This is because under the hood every table is a single partition. With this you can quickly move data to an empty table and with some &quot;shell games&quot; instantly swap back to the old table.&lt;/p&gt;
&lt;p&gt;I have used this many times to remove billions of rows by selecting out only the few hundred thousand that I wanted to keep into a new table and swapping table partition pointers. The swap is instant and there is little to no downtime.&lt;/p&gt;
&lt;p&gt;Let&apos;s walk through an example of the process.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-- create test set of tables
CREATE TABLE dbo.TEST1(id INT)
CREATE TABLE dbo.TEST2(id INT)

-- populate test1 with 10000 rows of data
DECLARE @i INT = 0
WHILE @i &amp;lt; 10000
BEGIN
    INSERT INTO dbo.TEST1(id)
    VALUES(@i)
    SELECT @i += 1
END

-- view current state of things
SELECT * FROM dbo.TEST1
SELECT * FROM dbo.TEST2

-- switch data to second table
ALTER TABLE dbo.TEST1
SWITCH TO dbo.TEST2

-- view current state of things
SELECT * FROM dbo.TEST1
SELECT * FROM dbo.TEST2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have an idea of how this works, you can imagine that you have a table with billions of rows that you want to delete. DELETEs have to acquire a lock on the table at some level potentially preventing others from interacting with it. SELECTs however are much quicker and can be done in parallel without affecting others.&lt;/p&gt;
&lt;p&gt;Below, we select out just the handful of rows that we want, truncate the original table, then swap the table pointers.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-- =========================
-- TRUNCATE TABLE SHELL GAME
-- =========================
-- move out set of data i want to keep
SELECT TOP 1000 * INTO dbo.TEMP_SHELL FROM dbo.TEST2

-- truncate orig table
TRUNCATE TABLE dbo.TEST2

-- move data metadata from shell to orig table
ALTER TABLE dbo.TEMP_SHELL
SWITCH TO dbo.TEST2

-- view current state of things
SELECT * FROM dbo.TEMP_SHELL
SELECT * FROM dbo.TEST2

-- remove shell table
DROP TABLE dbo.TEMP_SHELL

-- view current state of things
SELECT * FROM dbo.TEST1
SELECT * FROM dbo.TEST2

-- cleanup
DROP TABLE dbo.TEST1
DROP TABLE dbo.TEST2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This process has saved me countless hours of data processing and downtime.&lt;/p&gt;
&lt;p&gt;I have used it in ETLs, ad-hoc table cleanups, as well as to create a simple data archiving process that moves old data by quarter into another table for historical reporting keeping the primary table lean.&lt;/p&gt;
&lt;p&gt;This may not be such a concern now that Microsoft has opened up the table partitioning feature to all editions of SQL Server, but still useful for situations where the complexity of managing table partitioning outweighs the benifits.&lt;/p&gt;
&lt;p&gt;~ SK&lt;/p&gt;
</content:encoded></item><item><title>Start of a Journey</title><link>https://www.kichka.dev/posts/start-of-a-journey/</link><guid isPermaLink="true">https://www.kichka.dev/posts/start-of-a-journey/</guid><description>Today I embark on a new journey of writing down my thoughts and experiences in software development</description><pubDate>Mon, 15 Dec 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;A new Beginning&lt;/h1&gt;
&lt;p&gt;For a long time now I have been wanting to start writing my thoughts down on paper. I have a physical notebook where my thoughts and notes are haphazardly written which has this big downside of not being very searchable.&lt;/p&gt;
&lt;p&gt;So over the next couple of weeks I will be working on digitizing these notes and thoughts here.&lt;/p&gt;
&lt;p&gt;Come join me on this journey of inspiration lost and found.&lt;/p&gt;
&lt;p&gt;~ SK&lt;/p&gt;
</content:encoded></item></channel></rss>